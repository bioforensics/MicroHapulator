<!DOCTYPE html>
<html>
    <head>
        <title>MicroHapulator Report</title>
        <link rel="stylesheet" href="http://netdna.bootstrapcdn.com/bootstrap/3.0.0/css/bootstrap.min.css" media="screen">
        <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
        <script src="https://ajax.googleapis.com/ajax/libs/jqueryui/1.11.2/jquery-ui.min.js"></script>
        <script src="fancyTable.js"></script>
        <style type="text/css">
            h2 {
                margin-top: 50px;
            }
            .container {
                max-width: 750px;
                padding-top: 100px;
            }
            .alnrt {
                text-align: right;
            }
            p.caption {
                color: #666666;
                font-size: small;
                margin: 0 auto 30px auto;
                text-align: center;
                width: 85%;
            }
            p.title {
                color: #666666;
                font-size: small;
                margin: 30px auto -10px auto;
                text-align: center;
                width: 85%;
            }
            img {
                margin: 10px auto;
                width: 48%;
            }
            img.small {
                width: 24.5%;
            }
            img.center {
                display: block;
                margin-left: auto;
                margin-right: auto;
            }
            .fullwidth {
                width: 100%;
            }
            table {
                margin: 12pt auto;
                width: 100%;
            }
            .scrollwrapper {
                overflow-x: auto;
                margin-bottom: 30px;
            }
            table.half {
                margin: 12pt auto 12pt auto;
                width: 50%;
            }
            td, th {
                padding-right: 10px;
                white-space: nowrap;
            }

            blockquote p {
                font-size: small;
            }

            blockquote h3 {
                margin-top: 0;
            }

            ::-webkit-scrollbar {
                width: 5px;
                height: 5px;
            }

            ::-webkit-scrollbar-thumb {
                background: gray;
                border-radius: 10px;
            }
            ::-webkit-scrollbar-track{
                -webkit-box-shadow: inset 0 0 6px rgba(0,0,0,0.3);
                border-radius: 10px;
                background-color: #F5F5F5;
            }
        </style>
    </head>
    <body>
        <div class="container">
            <h1>MicroHapulator Report</h1>
            <p>
                Report generated at {{date}},<br />
                using <a href="https://microhapulator.readthedocs.io" target="_blank">MicroHapulator</a> version {{mhpl8rversion}}.
            </p>

            <h2>Table of Contents</h2>
            <ol>
                <li><a href="#readqc">Read QA/QC</a></li>
                {% if "r1readlen" in plots %}
                <li><a href="#readmerging">Read Merging</a></li>
                {% endif %}
                <li><a href="#readmapping">Read Mapping</a></li>
                <li><a href="#typing">Haplotype Calling</a></li>
                <li><a href="#filters">Genotype Calling</a></li>
            </ol>
            <p>
                A summary of the statistics presented in this report is aggregated in a single table available at <code>analysis/summary.tsv</code> in the working directory.
                Full-resolution graphics for each figure are also available in each <code>analysis/{samplename}/</code> subdirectory.
            </p>

            <a name="readqc"></a>
            <h2>Read QA/QC</h2>
            <p>
                QC reports for the input reads are generated using <a href="https://www.bioinformatics.babraham.ac.uk/projects/fastqc/" target="_blank">FastQC</a> and compiled into a single report with <a href="https://multiqc.info/" target="_blank">MultiQC</a>.
                A link to the MultiQC report is provided below.
            </p>
            <blockquote>
                <p>
                    <strong>NOTE</strong>: FastQC was designed for QC of whole-genome shotgun NGS reads prior to genome asssembly.
                    A QC warning or failure for some modules (such as per-base sequence content or sequence duplication levels) may or may not be a concern with MH reads.
                    Interpret results with care!
                </p>
            </blockquote>
            <p><a href="analysis/multiqc_report.html",  target="_blank">Click here to open MultiQC report in a new tab</a></p>

            {% if read_length_table is none %}
                {% if "r1readlen" in plots %}
                    <img src="analysis/r1-read-lengths.png" />
                    <img src="analysis/r2-read-lengths.png" />
                    <p class="caption"><strong>Figure 1.1</strong>: Ridge plots showing the length distribution of input R1 (left) and R2 (right) reads.</p>
                {% else %}
                    <img class="center" src="analysis/read-lengths.png" />
                    <p class="caption"><strong>Figure 1.1</strong>: Ridge plot showing the length distribution of input reads.</p>
                {% endif %}
            {% else %}
                {% if "r1readlen" in plots %}
                <p class="title"><strong>Table 1.1</strong>: Uniform read lengths for each sample.</p>
                <table class="half">
                    <tr>
                        <th>Sample</th>
                        <th class="alnrt">Length R1</th>
                        <th class="alnrt">Length R2</th>
                    </tr>
                    {% for i, row in read_length_table.iterrows() %}
                    <tr>
                        <td>{{ row.Sample }}</td>
                        <td class="alnrt">{{ row.LengthR1 }}</td>
                        <td class="alnrt">{{ row.LengthR2 }}</td>
                    </tr>
                    {% endfor %}
                </table>
                {% else %}
                <p class="title"><strong>Table 1.1</strong>: Uniform read length for each sample.</p>
                <table class="half">
                    <tr>
                        <th>Sample</th>
                        <th class="alnrt">Length</th>
                    </tr>
                    {% for i, row in read_length_table.iterrows() %}
                    <tr>
                        <td>{{ row.Sample }}</td>
                        <td class="alnrt">{{ row.Length }}</td>
                    </tr>
                    {% endfor %}
                </table>
                {% endif %}
            {% endif %}

            {% if reads_are_paired %}
            <p>
                Prior to subsequent analysis, reads are filtered for ambiguous sequence content.
                Any read comprised of more than {{"{:.0f}".format(ambiguous_read_threshold * 100)}}% ambiguous bases (<code>N</code>) is discarded, along with its mate.
                (This threshold can be configured with the <code>--ambiguous-thresh</code> argument.)
                The table below shows the number of read pairs that were removed from each sample and which read(s) in the pair exceeded the filtering threshold.
            </p>
            <p class="title"><strong>Table 1.2</strong>: Metrics for read filtering based on ambiguous content.</p>
            <table>
                <tr>
                    <th>Sample</th>
                    <th class="alnrt">Total Pairs</th>
                    <th class="alnrt">R1 Only Failed</th>
                    <th class="alnrt">R2 Only Failed</th>
                    <th class="alnrt">Pair Failed</th>
                    <th class="alnrt">Pairs Removed</th>
                    <th class="alnrt">Pairs Kept</th>
                    <th class="alnrt">Retention</th>
                </tr>
                {% for sample, stats in qc.items() %}
                <tr>
                    <td>{{sample}}</td>
                    <td class="alnrt">{{stats.ambig.total_reads}}</td>
                    <td class="alnrt">{{stats.ambig.excluded_r1}}</td>
                    <td class="alnrt">{{stats.ambig.excluded_r2}}</td>
                    <td class="alnrt">{{stats.ambig.excluded_both}}</td>
                    <td class="alnrt">{{stats.ambig.excluded}}</td>
                    <td class="alnrt">{{stats.ambig.retained}}</td>
                    <td class="alnrt">{{stats.ambig.retention_rate}}</td>
                </tr>
                {% endfor %}
            </table>
            {% else %}
            <p>
                Prior to subsequent analysis, reads are filtered for length and ambiguous sequence content.
                Any read comprised of more than {{"{:.0f}".format(ambiguous_read_threshold * 100)}}% ambiguous bases (<code>N</code>) is discarded.
                Reads less than {{"{:,}".format(read_length_threshold)}} bp in length are also excluded from all subsequent analysis.
                (These thresholds can be configured with the <code>--ambiguous-thresh</code> and <code>--length-thresh</code> arguments.)
            </p>
            <p class="title"><strong>Table 1.2</strong>: Read filtering metrics.</p>
            <table>
                <tr>
                    <th>Sample</th>
                    <th class="alnrt">Total Reads</th>
                    <th class="alnrt">Filtered (Ambiguous)</th>
                    <th class="alnrt">Filtered (Length)</th>
                    <th class="alnrt">Reads Kept</th>
                </tr>
                {% for sample, stats in qc.items() %}
                <tr>
                    <td>{{sample}}</td>
                    <td class="alnrt">{{stats.total_reads}}</td>
                    <td class="alnrt">{{stats.filtered_ambig}}</td>
                    <td class="alnrt">{{stats.filtered_length}}</td>
                    <td class="alnrt">{{stats.retention}}</td>
                </tr>
                {% endfor%}
            </table>
            {% endif %}

            {% if "r1readlen" in plots %}
            <a name="readmerging"></a>
            <h2>Read Merging</h2>
            <p>
                Paired end reads are merged using <a href="https://ccb.jhu.edu/software/FLASH/" target="_blank">FLASh</a>.
                Merged reads less than {{"{:,}".format(read_length_threshold)}} bp in length are filtered out prior to read mapping and excluded from all subsequent analysis.
                (This threshold can be configured with the <code>--length-thresh</code> argument.)
            </p>
            <p class="title"><strong>Table 2.1</strong>: Read merging metrics.</p>
            <table class="half">
                <tr>
                    <th>Sample</th>
                    <th class="alnrt">Filtered Reads</th>
                    <th class="alnrt">Merged Reads</th>
                    <th class="alnrt">Merge Rate</th>
                </tr>
                {% for sample, stats in qc.items() %}
                <tr>
                    <td>{{sample}}</td>
                    <td class="alnrt">{{stats.merge.total_reads}}</td>
                    <td class="alnrt">{{stats.merge.merged_reads}}</td>
                    <td class="alnrt">{{stats.merge.merge_rate}}</td>
                </tr>
                {% endfor %}
            </table>
            <img class="center" src="analysis/merged-read-lengths.png" />
            <p class="caption"><strong>Figure 2.2</strong>: Ridge plot showing the length distribution of merged reads.</p>

            <p class="title"><strong>Table 2.3</strong>: Metrics for read length filtering.</p>
            <table>
                <tr>
                    <th>Sample</th>
                    <th class="alnrt">Total Merged Reads</th>
                    <th class="alnrt">Reads Removed</th>
                    <th class="alnrt">Reads Kept</th>
                    <th class="alnrt">Retention</th>
                </tr>
                {% for sample, stats in qc.items() %}
                <tr>
                    <td>{{sample}}</td>
                    <td class="alnrt">{{stats.length.total_reads}}</td>
                    <td class="alnrt">{{stats.length.excluded}}</td>
                    <td class="alnrt">{{stats.length.kept}}</td>
                    <td class="alnrt">{{stats.length.retention_rate}}</td>
                </tr>
            {% endfor%}
            </table>
            {% endif %}

            <a name="readmapping"></a>
            <h2>Read Mapping</h2>
            <p>Filtered {% if reads_are_paired %} and merged {% endif %} reads are aligned to marker reference sequences using <a href="http://bio-bwa.sourceforge.net/bwa.shtml" target="_blank">BWA MEM</a> and formatted, sorted, and indexed using <a href="http://www.htslib.org/" target="_blank">SAMtools</a>.</p>
            <p class="title"><strong>Table 3.1</strong>: Read mapping metrics.</p>
            <table>
                <tr>
                    <th>Sample</th>
                    <th class="alnrt">Filtered Reads</th>
                    <th class="alnrt">Mapped Reads</th>
                    <th class="alnrt">Mapping Rate</th>
                    <th class="alnrt">Chi-square</th>
                </tr>
                {% for sample, stats in mapping_summary.items() %}
                <tr>
                    <td>{{ sample }}</td>
                    <td class="alnrt">{{ stats.total_reads }}</td>
                    <td class="alnrt">{{ stats.mapped_reads }}</td>
                    <td class="alnrt">{{ stats.mapping_rate }}</td>
                    <td class="alnrt">{{ stats.chi_square }}</td>
                </tr>
                {% endfor %}
            </table>
            <br />
            <p>
                The reported chi-square statistic is a measure of read coverage imbalance between markers, and can be compared among samples sequenced using the sample panel:
                the minimum value of 0 represents perfectly uniform coverage across markers, while the maximum value of D occurs when all reads map to a single marker (D represents the degrees of freedom, or the number of markers minus 1).
                A visual representation of interlocus balance is shown in <strong>Figure 3.4</strong>.
            </p>
            <p>Using mapping information, each read is assigned to one of four categories as follows.</p>
            <ul>
                <li><strong>On-target</strong>: read maps only to the expected MH loci</li>
                <li><strong>Off-target</strong>: read maps to the human reference genome, but not to any expected MH loci</li>
                <li><strong>Contaminant</strong>: read does not map to the human reference genome</li>
                <li><strong>Repetitive</strong>: read maps to the expected MH loci, but also (preferentially) to other locations in the human reference genome</li>
            </ul>
            <img class="fullwidth" src="analysis/read-mapping-qc.png" />
            <p class="caption"><strong>Figure 3.2</strong>: Bar graph showing the number of reads for each sample, broken down into four categories: on-target, off-target, contaminant, and repetitive.</p>
            <p class="title">
                <strong>Table 3.3</strong>: The total number of reads mapped to each marker, and the subset of those reads marked as repetitive, broken down by sample.
                Table columns are sortable, and marker names link to a marker detail page.
            </p>
            <div class="scrollwrapper">
                <table id="mapping_rates_table" class="pagination_table">
                    <thead>
                        <tr>
                            <td></td>
                            {% for sample in typing_rates.keys() %}
                            <td style="visibility: collapse;">{{sample}}</td>
                            <td style="font-weight:bold">{{sample}}</td>
                            {% endfor %}
                        </tr>
                        <tr>
                            <th>Marker</th>
                            {% for i in range(len(samples)) %}
                            <th class="alnrt" style="font-weight:bold" data-sortas="numeric">Reads</th>
                            <th class="alnrt" style="font-weight:bold" data-sortas="numeric">Repetitive</th>
                            {% endfor %}
                            <td></td>
                        </tr>
                    </thead>
                    <tbody>
                        {% for marker, marker_data in repetitive_reads_by_marker.items() %}
                        <tr>
                            <td><a href="marker-detail-report.html?marker={{marker}}" target="_blank">{{marker}}</a></td>
                            {% for sample in samples %}
                            <td class="alnrt" data-sortvalue="{{ marker_data[sample].mapped }}">{{ "{:,d}".format(marker_data[sample].mapped) }}</td>
                            <td class="alnrt" data-sortvalue="{{ marker_data[sample].repetitive }}">{{ "{:,d}".format(marker_data[sample].repetitive) }}</td>
                            {% endfor %}
                        </tr>
                        {% endfor %}
                    </tbody>
                </table>
            </div>

            {% for plot in plots["locbalance"] %}
            <img src="{{plot}}" />
            {% endfor %}
            <p class="caption"><strong>Figure 3.4</strong>: Histograms showing the interlocus balance for each sample.</p>

            <a name="typing"></a>
            <h2>Haplotype Calling</h2>
            <p>Haplotypes are called empirically using <code>mhpl8r type</code>mhpl8r type as follows. MicroHapulator examines each
                aligned read to determine its suitability for haplotype calling: this is a <em>typing event</em>. If the read
                alignment spans all SNPs of interest, the typing event is successful and a haplotype call is made. If not, the
                typing event is failed and no haplotype call is made. (<em>Note that if more than one marker is defined at a given
                locus, MicroHapulator can attempt multiple typing events per read. In this case the number of <strong>Attempted Typing
                Events </strong> will exceed the number of <strong>Mapped Reads.</strong></em>) Collectively, the tallies of each observed haplotype represent a
                typing result for each sample. The typing rate is calculated as the number of successful typing events divided by
                the total number of attempted typing events.</p>
            <p class="title"><strong>Table 4.1</strong>: Read typing metrics.</p>
            <table>
                <tr>
                    <th>Sample</th>
                    <th class="alnrt">Mapped Reads</th>
                    <th class="alnrt">Attempted Typing Events</th>
                    <th class="alnrt">Successful Typing Events</th>
                    <th class="alnrt">Typing Success Rate</th>
                </tr>
                {% for i, row in summary.iterrows() %}
                <tr>
                    <td>{{row.Sample}}</td>
                    <td class="alnrt">{{ "{:,}".format(row.Mapped) }}</td>
                    <td class="alnrt">{{ "{:,}".format(row.TypedAttempted) }}</td>
                    <td class="alnrt">{{ "{:,}".format(row.TypedSuccess) }}</td>
                    <td class="alnrt">{{ "{:.2f}".format(row.TypingRate * 100) }}%</td>
                </tr>
                {% endfor %}
            </table>
            <p class="title">
                <strong>Table 4.2</strong>: Typing rate of each individual marker, broken down by sample.
                Table columns are sortable, and marker names link to a marker detail page.
            </p>
            <div class="scrollwrapper">
                <table id="typing_rates_table" class="pagination_table">
                    <thead>
                        <tr>
                            <th>Marker</th>
                            {% for sample in typing_rates.keys() %}
                            <th class=alnrt style="font-weight:bold">{{sample}}</th>
                            {% endfor %}
                        </tr>
                    </thead>
                    <tbody>
                        {% for markername in markernames %}
                        <tr>
                            <td><a href="marker-detail-report.html?marker={{markername}}" target="_blank">{{markername}}</a></td>
                            {% for sample_data in typing_rates.values()%}
                            <td class="alnrt" data-sortvalue="{{sample_data.loc[markername, 'TypingRate']}}">{{"{:,.2f}".format(sample_data.loc[markername, 'TypingRate']*100)}}%</td>
                            {% endfor %}
                        </tr>
                        {% endfor %}
                    </tbody>
                </table>
            </div>

            <a name="filters"></a>
            <h2>Genotype Calling</h2>
            <p>
                Two types of thresholds are applied to each typing result using <code>mhpl8r filter</code> to discriminate between true MH alleles (haplotypes) and false alleles resulting from sequencing error or other artifacts.
                A static detection threshold, based on a fixed number of reads, is used to filter out low-level noise.
                A dynamic analytical threshold, based on a percentage of the total reads at the locus (after removing alleles that fail the detection threshold), accounts for fluctuations in the depth of coverage between loci, samples, and runs, and can filter out higher-level noise in most cases.
                The haplotype tallies, after all filters have been applied, represents the <em>genotype call</em> for that sample.
            </p>
            <p class="title">
                <strong>Table 5.1</strong>: Detection thresholds and analytical thresholds for each marker.
                Table columns are sortable, and marker names link to a marker detail page.
            </p>
            <table class="half pagination_table">
                <thead>
                    <tr>
                        <th>Marker</th>
                        <th class="alnrt">Detection</th>
                        <th class="alnrt">Analytical</th>
                    </tr>
                </thead>
                <tbody>
                    {% for marker, row in thresholds.iterrows() %}
                    <tr>
                        <td><a href="marker-detail-report.html?marker={{marker}}" target="_blank">{{marker}}</a></td>
                        <td class="alnrt" data-sortvalue="{{row.Static}}">{{row.Static}}</td>
                        <td class="alnrt" data-sortvalue="{{row.Dynamic}}">{{"{:.1f}".format(row.Dynamic * 100)}}%</td>
                    </tr>
                    {% endfor %}
                </tbody>
            </table>
            <hr />
            <p>
                For single-source samples, we expect the two alleles at heterozygous loci to have roughly even abundance.
                The following plots show the <em>relative</em> abundance of the major and minor allele for each marker with a heterozygous genotype (markers are sorted by absolute combined abundance, which is printed above each pair of allele counts).
                For known DNA mixtures, these plots can be safely ignored.
                But for suspected single-source samples, if there is substantial imbalance between major and minor allele counts at numerous loci, the sample should be examined more closely for the presence of a minor DNA contributor.
            </p>
            {% for plot in plots["hetbalance"] %}
            <img src="{{plot}}" class="fullwidth" />
            {% endfor %}
            <p class="caption"><strong>Figure 5.2</strong>: Bar graphs showing heterozygote balance for all samples.</p>
        </div>
    </body>
    <script type="text/javascript">
        $(".pagination_table").fancyTable({
            sortColumn: 0,
            pagination: true,
            perPage: 15,
            globalSearch: true,
            sortable: true,
            globalSearchExcludeColumns: [2, 3, 4, 5, 6, 7, 8, 9],
        });
    </script>
</html>
